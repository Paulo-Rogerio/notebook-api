- Udemy

- Verbos HTTP (POST)
curl http://localhost:3000/contacts -i -v -X POST -H "Content-Type: application/json" -d '{"name": "Paulo", "email": "paulo@paulo.com"}'

- GET
curl http://localhost:3000/contacts/101 -i -v 

- PUT ( atualiza todos os itens do recurso , todos os campos )
- PATCH ( atualiza um campo )

curl http://localhost:3000/contacts/101 -i -v -X PATCH -H "Content-Type: application/json" -d '{"name": "Paulo Rogerio", "email": "paulo@paulorogerio.com"}'

- DELETE

curl http://localhost:3000/contacts/101 -i -v -X DELETE

====================================

- Status Code Ruby (https://httpstatuses.com/)

- Map / Collect ( Cria um novo array a partir de um array ja existente )

x = [1,2,3,4,5]
x.class
x.map { |i| i*3 }

- Assim eu forco o x a receber os novos elementos apos o calculo.
x.collect! {|i| i*3}

=========================================

- Active Support JSON 

Tem dois elementos ( encode e decode )

https://edgeapi.rubyonrails.org/classes/ActiveSupport/JSON.html

Encode => Pega um hash e codifica para JSON

Decode => Pega um string (json) e codifica para HASH

x = {nome: "paulo"}
x.class
=> Hash
y = x.to_json
=> "{\"nome\":\"paulo\"}"

# Faz  a mesma coisa
y = ActiveSupport::JSON.encode(x)
=> "{\"nome\":\"paulo\"}"
y.class
=> String

=======================================

- Active Model Serializer JSON

https://edgeapi.rubyonrails.org/classes/ActiveModel/Serializers/JSON.html

Tem dois elementos ( as_json e from_json )


as_json   => Pega um elemento do Model e represnta-lo como um hash

Ex:

c = Contact.first
c.class 
# É do tipo contato
=> Contact(id: integer, name: string, email: string, birthdate: date, created_at: datetime, updated_at: datetime)

# Vai transformar meu objeto contato em um objeto do tipo hash
c.as_json
c.as_json.class

# Como ele agora é um hash , posso aplicar um to_json para transforma-lo em uma string.
c.as_json.to_json
=> String

========================================

Render JSON


O que esse cara faz?

Ex:

def index
  @contact = Contact.all
  render json: @contacts
end

Por debaixo dos panos ele faz a magica acontecer... Transforma um objeto do tipo contato em texto plano (string).

def index
  @contact = Contact.all
  render json: @contacts.as_json.to_json
end


========================================

Ativar a raiz na sua resposta ( root: true ) Na controller

=======================================

Quais dados que quero que apareca ( Ex: apenas nome e email )

render json: @contacts, status: :ok, only: [:name, :email]

Assim preciso personalizar para cada method, uma maneira simples de resolver isso é reescrever o as_json
assim ele se aplicará em todos os methods. O super invoca o as_json original

===========================

Aula 16

bundle exec rails g migration add_kind_to_contact kind:references
bundle exec rails g scaffold kind description:string

bundle exec rails db:drop db:create db:migrate dev:setup

Fazer assossiacao ( Dentro do model contact )

belongs_to :kind


======================================

So que ele envia o ID , vamos aprender como enviar o nome.
Aleterar o model contact o method "as_json"

Com o include ele faz alinhada ( um dentro do outro )

    def as_json(otions={})
        super(
            root: true,
            methods: :autor, 
            include: { kind: { only: :description }}  
        )
    end

======================================

Se eu quiser trazer outro atributo chamado "kind_description" , neste caso ele não sera nexted (alinhado)

    def kind_description
       self.kind.description
    end

    def as_json(otions={})
        super(
            root: true,
            methods: [:autor, :kind_description]  
        )
    end

==================================================

Usando method POST com (belongs_to) Se nao informar o kind , propositalmente , ele irá resmungar e fazer rollback
Como foi definido um belong_to no model, sou obrigado a informar isso na hora de fazer o post.

Agora se eu definir no meu model que o belongs_to é opcional (belongs_to :contact, optional: true)
Dessa forma consiguirei cadastrar sem informar o kink


curl -X POST \
  http://localhost:3000/contacts \
  -H 'cache-control: no-cache' \
  -H 'content-type: application/json' \
  -d '{
    "name": "Paulao da Regulagem",
    "email": "paulo@paulao.io",
    "birthdate": "1983-09-17"
}'

Saída do console ({"kind":["must exist"]})

   (0.2ms)  BEGIN
   (1.4ms)  ROLLBACK



Mesmo depois de ter colocado a flag do option: true e caso eu envie meu POST novamente infomando o kind_id
ainda assim receberei um erro informando que o parametro kind_id não foi permitido, ou seja, ele cadastra o 
novo contact , mas a coluna kind_id ainda fica preenchida como null

Unpermitted parameter: :kind_id


Para resolver isso add na controller contact.rb

def contact_params
  params.require(:contact).permit(:name, :email, :birthdate, :kind_id)
end

====================================

Criar uma associaçao (HAS_MANY)

Sera craido apenas um model (telefone) não sera criado um scaffold.
Permitir que 1 contato possa ter varios numeros de telefone. ( Contatos possui muitos telefones )


bundle exec rails g model Phone number:string contact:references

Model contact
has_many :phones


==================================


O model telefone não foi criado usando scaffold, ou seja, o telefone precisara ser criado no momento em for criado um contato ou atualizando um contato.


Isso so é possivel por conta "accepts_nested_attributes_for"

https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html


# one-to-many

No model contact vou permitir que os atributos de telefone sejam passados e criado no momento em que estiver criando
um contato

class Contact < ApplicationRecord
    belongs_to :kind
    has_many :phones
    accepts_nested_attributes_for :phones
end


Criar um contato na mao (console)

Contact.create(name: "paulo", email: "paulo@paulo", birthdate: "10/10/20", kind_id: 3)


Pegar os dados colocar dentro de uma variavel que sera passado como parametro.

Ex:

# bundle exec rails c

[1] pry(main)> params = { contact: { name: "paulo", email: "paulo@paulo", birthdate: "10/10/20", kind_id: 3 }}
=> {:contact=>{:name=>"paulo", :email=>"paulo@paulo", :birthdate=>"10/10/20", :kind_id=>3}}

[1] pry(main)> params[:contact][:name]

Criar um contato a partir dos parametros passado, a partir da chave contact

[1] pry(main)> Contact.create(params[:contact])


[1] pry(main)> params = { contact: { 
                  name: "paulo", 
                  email: "paulo@paulo", 
                  birthdate: "10/10/20", 
                  kind_id: 3,
                  phones_attributes: [
                    { number: '1234'},
                    { number: '5678'},
                    { number: '9101'}
                  ]
                }}


[1] pry(main)> Contact.create(params[:contact])


Como fiz esse exemplo direto no console nãp precisei liberar na controller os parametros permitidos na controler dos contatos.

========================================

AJUSTANDO A CONTROLLER

Ao criar um novo contato, é chamado a rota "/contact" pelo verbo POST
Ele chama a method create que por sua vez invoca o method privado "contact_params"

def contact_params
  params.require(:contact).permit(:name, :email, :birthdate, :kind_id)
end

Esse method por sua vez, espera que vc tenha um json que tenha uma chave comecando com contact. Geralmente nas requisiçoes POST passamos isso aqui para popular os dados. 



Se fizermos um POST para criar um novo contact, como no exemplo abaixo, não dará erro na tela , pois esse novo parametro
ainda não existe na controller , ou seja , sera criado um novo contato sem telefone.


Devo librar a chave "phones_attribuites" dentro do method contact_params

def contact_params
    params.require(:contact).permit(:name, :email, :birthdate, :kind_id, 
                                    :phones_attributes [:number])
end



{
    "name": "Paulao da Regulagem",
    "email": "paulo@paulao.io",
    "birthdate": "1983-09-17",
    "kind_id": 2,
    "phones_attributes": [
      { "number": "5555" },
      { "number": "7777" }
    ]
}

Mesmo assim ainda não cadastrou o telefone, isso porque ele espera que o elemento contatc seja declarado na raiz do json.

----------------------



{ "contact":
    {
      "name": "Paulao da Regulagem",
      "email": "paulo@paulao.io",
      "birthdate": "1983-09-17",
      "kind_id": 2,
      "phones_attributes": [
        { "number": "5555" },
        { "number": "7777" }
      ]
    }
}